## Необходимая гибкость

При всём богатстве способов стилизации элементов страницы, простота синтаксиса и ограниченность встроенных возможностей по организации таблиц стилей приводят к сложным ситуациям:

- В каждый товар в списке товаров нужно добавить список акций, но он наследует стили списка товаров. Добавим `!important`, делов-то!
- У нас десять кнопок с одинаковым внешним видом, но с классами, не соответствующими классу страницы, которую я верстаю. Сделаю одиннадцатую.
- Не знаю, делал ли кто-нибудь уже анкету на этом проекте. Сверстаю свою.
- У нас тут разметка немного поправилась. Давайте переделаем её в двенадцати шаблонах!

Какие способы вёрстки приводят к проблемам? Попробуем разобраться на простом примере.

Представим, что необходимо сверстать виджет с акциями, в котором должен быть заголовок и список акций. Можно с этой задачей справиться и так:

```html
<div id="actions">
  <h3>Header</h3>
  <ul>
    <li>item1</li>
    <li>item2</li>
    <li>item3</li>
  </ul>
</div>
```

```css
div#actions {...}
div#actions h3 {...}
div#actions ul {...}
div#actions li {...}
```

Теперь, если понадобится добавить внутрь элемента списка ещё один список, нужно писать уже более длинный и бессмысленный селектор `div#actions li li`, стилями которого придётся перебарывать стили `div#actions li`.

Проблема возникнет и в том случае, когда потребуется сверстать точно такой же виджет, только для товаров. В этой ситуации использовать такую же вёрстку не получится (нам же не нужно, чтобы виджет с товарами был с классом или идентификатором `actions`). Из-за этого приходится дублировать код или даже верстать заново, если забылось местоположение сделанного.

В конце концов, добавить что-то новое в имеющуюся вёрстку станет слишком тяжело, а переделывать участок разметки заново может быть не легче оттого, что придётся исправлять этот участок во всех шаблонах.

Чтобы получить универсальный элемент, способный использоваться снова и снова, не ломающий любые другие добавляемые в него элементы, необходимо изначально создавать его по специальным правилам.

Ко всему прочему, его элементы также должны быть переносимыми и способными использоваться отдельно от их контейнера (мало ли куда их ТЗ занесёт).

Вспомним, что требуется: виджет с заголовком и списком. Список, ко всему прочему, с акциями.

```html
<div class="Widget actions">
  <h3 class="Widget__header"></h3>
  <ul class="WidgetList">
    <li class="WidgetList__item"></li>
    <li class="WidgetList__item"></li>
    <li class="WidgetList__item"></li>
  </ul>
</div>
```

```css
.Widget {...}
.Widget.actions {...}
.WidgetList {...}
.WidgetList__item {...}
```

Поясню изменения: виджет — смысл жизни этого контейнера, поэтому и класс его семантичен — `Widget`. У виджета может быть заголовок `.Widget__header`. В виджет вставляется список `.WidgetList`, а элементы его — `.WidgetList__item`. Контейнер модифицируется при помощи класса `actions`.

Одно из важнейших качеств вёрстки — гибкость, то есть возможность использовать все элементы многократно, в разных условиях и окружениях. Гибкость обеспечивается, в первую очередь, **контекстной независимостью** элементов и их **универсальностью**.

Оценивать качество вёрстки, как и используемых в разработке приёмов, следует именно оценивая их гибкость, то есть стойкость под напором изменений.

Например, использование градиентов на ЦСС позволяет быстро изменять их цвет, не перерисовывая картинку с градиентом, а отказ от использования тегов и идентификаторов в селекторах поможет избежать большинства проблем с наследованием и со специфичностью.

Когда не ясно, _что принесёт завтрашний день_, когда вёрстка всей страницы может _полностью измениться из-за перевернувшихся концепций_ или из-за _внезапного осознания ущербности согодняшней вёрстки_, именно тогда возможность изменить поведение и отображение любого элемента на странице, не затронув все остальные, становится как никогда актуальной.

Следуйте следующим правилам:

- Специфичность элементов должна быть одинаково мала, чтобы правило было легко переопределяемым: не использовать селекторы по идентификаторам, `!important`, ограничить использование каскада.
- Давать каждому элементу интерфейса уникальный класс, по которому к нему можно было бы сразу обратиться, в том числе, и в джс.
- Документировать, чтобы не забывать о проделанной работе.

Вёрстка содержимого должна быть максимально семантичной, чтобы все его потребители могли распознать смысл, заложенный в нём.

Вёрстка интерфейса же должна быть полной, чтобы быть легко модифицируемой, описанной во всех своих состояниях, не зависимой от окружения, не влияющей на другие элементы интерфейса.

> Что не так с `!important`?

Эта декларация делает значение свойства очень специфичным, а, значит, с большим трудом переопределяемым, потому и использовать его следует с осторожностью, только там, где есть полнейшая уверенность в будущем **этого конкретного правила.**

Похожая ситуация с использованием идентификаторов (`#id`) в селекторах. Идентификатор сам по себе очень специфичен, он [в 255 раз](http://codepen.io/chriscoyier/pen/lzjqh) специфичнее селектора с классом (если не использовать `!important`) и [вот почему](http://stackoverflow.com/a/12003060). Стилизовать элемент, привязываясь к идентификатору его контейнера, означает ограничивать его переносимость, такой элемент будет сильно зависим от такого контейнера.

В то же время, идентификаторы хорошо подходят для использования в скриптах. А если элементы, с которыми нужно взаимодействовать при помощи скрипта, неоднократно встречаются в документе или однотипны, то можно использовать класс со специальным префиксом `js-`. Такой класс не должен использоваться для стилизации.

Присваивать идентификаторы и скриптовые классы элементам должны **программисты клиентских скриптов.**

> Как же каскад?

Он остаётся, но в обезвреженном виде. Он не должен создавать проблем, мешая добавлять элементы, но будет служить на благо разработке, применяясь внутри элементов интерфейса и их объединениях. Используя его, стоит всегда помнить, что он работает только в той структуре, которая **описана в его селекторе.**

> Можно ли использовать `+`, `~`, `>` и прочие `nth-child` в селекторах?

Конечно можно, но всегда нужно помнить, чем полезны такие конструкции и чем вредны. Полезны удобством доступа к элементу в структуре, вредны привязкой к ней.

> Нужно ли документирование?

Создавая для себя удобства в виде переиспользуемых модулей, не нужно забывать и о других разработчиках, которым они могут пригодиться. Поэтому много времени нужно уделять документированию всего, что вы делаете.

Дизайнеры же всегда должны использовать уже имеющиеся элементы интерфейса, создание нового или модификация сделанного всегда должны быть серьёзно мотивированы.

> Почему нужно добавлять классы всем элементам? Почему бы не добавить только нескольким, а остальные стилизовать каскадом?

Потому что каскад лишает вёрстку контекстной независимости, она становится зависима от положения элементов в документе, от их количества, от их состояния.

Мне понравилась аналогия из [этой статьи](http://csswizardry.com/2012/10/a-classless-class-on-using-more-classes-in-your-html/).

Представьте, что вы учитель и пытаетесь успокоить детей, у которых нет имён. Вы можете обратиться к ним таким образом:

- мальчик через два ряда: `el:nth-of-type() {}`
- девочка рядом с окном: `el + el {}`
- первый мальчик, сидящий на застеленной ковром зоне: `el > el:first-of-type {}`
- девочка недалеко от девочки рядом с мальчиком под лампой: `el > el + el ~ el {}`

Конечно, такая ситуация утрирована, но посыл верный — именно так верстается без должного применения классов.

Ещё одна аналогия на эту тему [в этой статье](http://engineering.appfolio.com/2012/11/16/css-architecture/): думайте о селекторе `#itemsList li div { }`, как о гранате, а о `.mainNavSub { }`, как о снайперской винтовке. Граната может отлично помочь сегодня, но никто не знает, когда невинный гражданин может попасть в зону поражения.

Отсутствие **тегов** в селекторе позволяет использовать элементы интерфейса в любых контекстах, в том числе, в целях обеспечения валидности (например, при вставке блочного элемента в строчный получится быстро исправить эту ошибку, изменив теги).

На первоначальное построение таких элементов будет уходить больше времени, чем на «просто вёрстку». Но это время компенсируется на других этапах, когда заново перевёрстывать не будет необходимости. Чтобы не было проблем в будущем, нужно максимально качественно сделать работу **в настоящем**.

Если искать аналогии с программированием, все селекторы в стилях находятся _в глобальной области видимости_: любой селектор, состоящий из одного элемента может повлиять на любой же элемент, если у него такой же класс. Поэтому нужно, чтобы селекторы были как можно более уникальными.

Необходимо выработать способ подбора классов для элементов, чтобы их стили не пересекались друг с другом.

В программировании для решения схожей проблемы применяется **замыкание**.


## Замыкания в ЦСС

Чтобы ограничить действие цсс-правил, выбирается сущность, внутри которой будет производиться замыкание. Такие сущности называются в разных методологиях по-разному: _Блок_, _Модуль_, _Группа_. Так как слово _Фундамент_ по смыслу ближе к строительству, будет использоваться строительное понятие **Блок**.

**Блок** — законченная и независимая часть интерфейса, из **блоков** строится страница. Состоит из **элементов**. **Блок** и его **элементы** могут изменяться **модификаторами**. Да, это примерно так же, как и в [яндексовском БЭМе](http://ru.bem.info/method/definitions/).

**Блоки** могут вкладываться друг в друга, объединяться друг с другом (таким образом расширяется функциональность блока).

Класс **блока** должен начинаться с большой буквы. Если блок — кнопка, то имя его класса может быть `Btn`:

```css
.Btn {
  ...
}
```

**Элемент** — составляющая часть блока, способная использоваться отдельно от него и с разным порядком вложенности друг в друга. Представляет собой контейнеры для содержимого, изменяются модификаторами.

Класс **элемента** образуется от класса блока, в котором этот элемент находится, и слова, обозначающего предназначение элемента. Эти слова разделяются при помощи `__`.

Если **элемент** — составная часть кнопки, отвечающая за её основное действие, то его класс может быть `Btn__trigger`:

```css
.Btn__trigger {
  ...
}
```

Если **элемент**  имеет сложную структуру, его составные части неотделимы от него, то его можно обозначать, как **блок**, наследуя название **блока**. Например, если в кнопке список:

```css
.BtnList {
  ...
}
.BtnList__item {
  ...
}
```

Отображение и поведение **блоков** и **элементов** может изменяться **модификаторами**.

**Модификатор** указывается в селекторе вместе с элементом, к которому применяется.

Если **модификатор** окрашивает кнопку в цвет ошибки, его класс может быть `error`, а селектор `.Btn.error`:

```css
.Btn.error {
  ...
}
```

**Модификатор** следует добавлять тому элементу, который включает в себя все модифицируемые элементы. При этом нужно учитывать, что если таких модификаций может быть несколько, то и модифицируемые элементы могут быть разными. Потому, проще всего модифицировать от **блока**, но следует всегда помнить о том, что **элемент** может использоваться и отдельно от него.

Классы **блоков** и **элементов** указываются в селекторах по одному, если не изменяются **модификаторами**.


#### Важно!

Блочная структура используется для организации кода стилей, но при этом необязательно следовать ей в разметке; **Блоки** могут не содержать в себе всех **элементов**, сами **элементы** могут находиться вне **блоков**.

Таким образом, выделяя на странице такие части интерфейса, разработчик конструирует для себя набор «кирпичиков», при помощи которых строит требуемый интерфейс.


### Объединения

Плюс неиспользования тегов в селекторах — помимо прочего — в том, что блоки можно объединять друг с другом.

Например,

```html
<a href="#" class="Link">
  <span class="Icon mail"></span>
</a>
```

В этой ситуации использование двух элементов избыточно.   
Почему бы не объединить блоки в одном элементе?

```html
<a href="#" class="Link Icon mail"></a>
```


### Как назвать это?

Класс составляется из **грамотно написанных** английских слов в **единственном числе**, точно характеризующих его **смысл**. Рекомендуется некоторые слова сокращать.

Для упрощения подбора имён можно использовать следующий список обозначений:
`overlay` — элемент, покрывающий собой всё, что под ним   
`product` — товар   
`wrapper` — обёртка для какого-то элемента, блока, набора блоков   
 `active` — элемент выбран, нажат, активирован   
 `header` — заголовок   
  `first` — первый элемент в наборе   
  `intro` — сокращённое описание, предварительная информация   
   `card` — карточка (товара, акции, приза)   
   `cart` — корзина   
   `last` — последний элемент в наборе   
    `btn` — кнопка   
    `col` — колонка   
    `pop` — всплывающее окно, подсказка

```
ul.ActionGifts >
  li.ActionGift
  li.ActionGift
```


### Глобальный модификатор

Это модификатор, который можно применять к любому элементу документа.

Он может содержать как одно объявление, так и несколько, и выполняет какую-то конкретную задачу, которая обычно описывается в его селекторе.

```css
/*
<label for="input">Заголовок</label>
<input id="input" type="text" />
*/

.fieldRequired:after {
  color: red;
  content: '*';
  font-weight: bold;
  margin-left: .3em;
}
```

Применяется прежде всего для стилизации _содержимого_ документа, редактируясь вместе с ним. При помощи таких классов можно быстро добиться требуемого отображения.

Применение в вёрстке _интерфейсов_ следует ограничить, ведь используя такой «атомарный» цсс, разработчик переносит оформление в разметку, чем лишает её _гибкости_. Быстро изменить поведение всех однотипных элементов на странице не получится, если это поведение зависит от такого класса, его придётся удалять **из всех элементов во всех шаблонах**. В то же время, никто не мешает использовать примеси препроцессоров, об этом в разделе [Абстрактность](#arch-abstraktnost).


## Признаки проблем

Если приходится что-то делать неправильно из-за уже сделанного неправильного, можно указывать новые стили таким образом:

```css
.ActionList {
  margin-bottom: 1.5em;
  
  /* SHAME */
  margin-left: 185px; /* из-за отсутствия контейнера приходится вручную оплывать плавающий блок .Product__photo */
}
```

По этому слову будет легко найти ошибки разработчика и наказать его.


### Модифицировать или отращивать?

Если вы заметили, что селектор превращается в башню:

```css
.Page.actions .Product__photo,
.Page.special .Product__photo,
.RelatedProducts .Product__photo
.Page.news .Product__photo {
  ...
}
```

То выделите такие стили в модификатор

```css
.Product__photo.small {
  ...
}
```

Всё оттого, что неправильно привязываться к конкретной странице в стилях, чтобы изменить отображение элемента:
  
```css
.Action__badge {
  width: 50px;
}
.Page.actionsList .Action__badge {
  width: 100px;
}
```

ведь может так получиться, что элемент должен будет одинаково изменяться не на одной странице, а на многих:

```css
.Page.actionsList .Action__badge,
.Page.actionItem .Action__badge,
.Page.cartWithActions .Action__badge,
.Page.somethingWithActionsToo .Action__badge {
  width: 100px;
}
```

В этой ситуации правильней модифицировать сам элемент:

```css
.Action__badge.full {
  width: 100px;
}
```

Кстати, если уж и пришлось давать странице класс, указывать его нужно в формате `.Page.something`.


### Универсальное правило

Если возможно, не позволяйте классу изменять слишком много свойств, ограничивайте его:

```css
.Product__code {
  color: #777;
  font-size: .75em;
  left: 100%;
  position: absolute;
  top: 10px;
}
```

Элементу `Product__code` позволено слишком много. Это ограничивает область его использования.
Некоторые свойства лучше изменять модификатором

```css
.Product__code {
  color: #777;
  font-size: .75em;
}
.Product__code.overlay {
  left: 100%;
  position: absolute;
  top: 10px;
}
```

Стили, связанные с положением и размерами элемента хорошо отделять от стилей отображения. Иногда, эти стили должны даваться разным элементам.


### Конфликтность

Бывает, нужно изменить поведение элемента несколько раз одинаково в определённых контекстах. Есть три выхода из этой ситуации.

- Использовать каскад и создавать составные селекторы. **Проблема** — составной селектор может вырасти до непотребных размеров.
- Изменять каждый элемент напрямую в его личном селекторе с требуемым каскадом. **Проблемы** — необходимость брать откуда-то пример или писать заново требуемый стиль, отсюда же проблема с повторяющимся кодом и сложностью изменения поведения в будущем. Некоторые из проблем может решить препроцессор.
- Модификация специальным классом — модификатором. **Проблемы** — именование, перенос стилизации в разметку.

Схожие проблемы и с объединением: имена модификаторов у объединяемых блоков могут совпадать.

Например, `.Btn.active.Bubble` — в этой ситуации активное состояние кнопки также является активным состоянием всплывающей индикации.

Выходов может быть несколько:

- Не объединять блоки с одинаковыми возможными модификатором, разносить их в разные сущности.
- Использовать замыкание на блок и для имён модификаторов, чтобы избежать совпадения: `.Btn.Btn--active.Bubble`

При использовании препроцессоров возможно отказаться от объединения идентичных блоков, применяя расширение их свойств. Не `.Btn.BtnGreen`, но сразу `.BtnGreen`.


## От абстрактных к контекстным

Элементы интерфейса на страницах сайта редко бывают **абстрактными**, они связаны общим назначением в более общих блоках и их объединениях. Внутри таких блоков формируется **контекст**.

Каждому элементу интерфейса необходим класс, обозначающий принадлежность к его **контексту**. При этом такой _контекстный элемент_ должен наследовать все необходимые свойства **абстрактных блоков**, которые ему необходимы для выполнения своих функций.

> Контекстные блоки — расширенные и обьединённые абстрактные, приправленные нужными только им стилями!

Инструменты БЭМа позволяет абстрагироваться от условностей разметки и вёрстки и размечать страницу не напрямую, гипертекстом, но с помощью более _высокоуровневого языка_.

Если нет возможности использовать такие шаблонизаторы, можно воспользоваться способностями препроцессоров для реализации **контекстных** блоков из **абстрактных** _в вёрстке_.

Например, можно выделить блок `.List` для сброса стилизации списков:

```css
.List {
  list-style-type: none;
  margin: 0;
  padding: 0;
}
.List__item {
  margin: 0;
}
```

Он же может применяться для расширения стилей другого блока, списка акций `.Actions__list`. При этом у этого списка могут быть свои стили, уточняющие. В этой ситуации `.List` абстрактный, а `.Actions__list` — контекстный.

Код расширяемого блока должен быть специфичней абстрактного.

Как и в ситуации с глобальными модификаторами, такое расширение возможно несколькими способами в зависимости от технических возможностей:

- указанием классов блоков вместе на одном элементе разметки;
- объединением селекторов блоков вручную или при помощи препроцессора.

Первый способ проблемен тем, что переносит оформление в разметку, чем **ухудшает изменяемость** блоков, но, одновременно, он **упрощает взаимодействие** абстрактных блоков друг с другом.

```html
<ul class="List Actions__list"></ul>
```

Второй оставляет стилизацию в вёрстке, но только при использовании препроцессоров, потому что вручную изменять селекторы придётся в разных местах и впоследствии станет сложно определить место изменения:

```css
.List,
.Actions__list {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

...

.Actions__list {
  background-color: red;
}
```

Препроцессор ([Стайлус](https://github.com/learnboost/stylus), например) имеет специальные функции для такого расширения — [примеси](https://github.com/LearnBoost/stylus/blob/master/docs/mixins.md), [расширение](https://github.com/LearnBoost/stylus/blob/master/docs/extend.md) — которые позволяют работать с расширяемым блоком напрямую:

```styl
.List {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

...

.Actions__list {

  /* в эту функцию передаётся класс,
     к которому в селектор будет добавлен класс расширяемого блока */
  @extend .List;
  background-color: red;
}
```

что компилируется в такой цсс

```css
.List,
.Actions__list {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

...

.Actions__list {
  background-color: red;
}
```

Однако, стоит помнить, что объединяя абстрактные блоки в контекстном, можно затруднить их взаимодействие, особенно если производить его при помощи составных селекторов. Контекстные блоки **должны упрощать** модификацию абстрактных, но **не должны усложнять** работу с ними.

Представим, что мы используем для создания **выпадающего меню** блок `.Bubble`, поведение которого задаём при помощи модификаторов `.top .onHover`. Этот блок используется **во множестве шаблонов**. Теперь, если будет необходимость исправить поведение нужным образом, придётся менять модификаторы на `.bottom .onActive`, что иногда _чревато_ ошибками и тратой времени.

Гораздо проще сделать однажды так:

```styl
.ProductBubble {
  @extend .Bubble.top;
  @extend .Bubble.onHover;
}
```

а в нужный момент исправить на это:

```styl
.ProductBubble {
  @extend .Bubble.bottom;
  @extend .Bubble.onActive;
}
```

В то же время, в разметке необходимо указывать класс блока `.Bubble` для упрощения взаимодействия блоков. О необходимости этого хорошо написано в главе «Component modifiers» [этой статьи](http://nicolasgallagher.com/about-html-semantics-front-end-architecture/) Николаса Галлахера.

Таким образом, контекстный блок поможет объединить под своим классом модификаторы абстрактных блоков, а также глобальные модификаторы.


## Структура итогового файла стилей

По своему предназначению и пригодности к изменениям можно выделить основные группы стилей:

0. Параметры — при использовании препроцессоров удобно выность переменные и функции в отдельную группу.
1. Нормализация — стили браузеров по умолчанию приводятся к определённой кроссбраузерной основе. В селекторах используются теги, чтобы охватить все элементы.
2. Абстрактные блоки — как общие, так и проектные.
3. Контекстные блоки проекта.
4. Коррекция — вспомогательный слой, чтобы разрешать противоречия, с которыми сложно справляться при помощи модифицирования Блоков. Необязателен.
5. Глобальные модификаторы — классы для быстрого изменения поведения элемента. Должны делать что-то конкретное, их действие должно быть раскрыто в классе селектора.

Их можно назвать _слои_, потому что каждая последующая группа опирается на стили предыдущей. **Важно**, что такая зависимость ограничивает возможности к _изменению_ базовых слоёв, они должны быть с самого начала разработки **максимально** абстрактны и правильны, **изменения** могут привести к **проблемам!**


## Межпроектность

Если нужно разрабатывать и поддерживать сразу несколько проектов, необходимо сделать так, чтобы блоки использовались везде одинаковые, без необходимости придумывать их всякий раз заново.

Идеально иметь **межпроектную библиотеку блоков**, из которой блоки копировались бы во все остальные проекты.

В первую очередь, туда добавлялись бы абстрактные блоки.

Весь код в такой библиотеке должен **проверяться** во всех состояниях, быть **наиболее универсальным**. К тому же, некоторые неуниверсальности всегда можно переопределить уже _на самом проекте_.

Удобнее всего работать с такой библиотекой при помощи **препроцессоров** или каких-либо других вспомогательных средств.

К тому же, необходимо использовать **инструмент для документации**, который бы отображал все блоки проекта. Каждый создаваемый блок должен быть максимально полно и подробно описан, чтобы не затеряться в сайте.


## В общем

- В селекторах не используются идентификаторы и `!important`, ограничено применение селекторов по тегу, по типу.
- В вёрстке выделяются блоки, элементы, модификаторы. Все они подробно документируются.
- Стили разделяются по слоям переопределений.
- Поддержка нескольких проектов одновременно упростится с созданием общей библиотеки блоков.


## Дополнительное чтение

### Общие мысли

http://engineering.appfolio.com/2012/11/16/css-architecture/   
http://nicolasgallagher.com/about-html-semantics-front-end-architecture/   
http://philipwalton.com/articles/css-architecture/   
http://adactio.com/journal/6537/   
http://www.kapowaz.net/articles/cargo-cult-css   
http://montagejs.org/blog/2013/10/24/BEM-syntax-with-ux-in-mind/   
http://thesassway.com/advanced/modular-css-an-example   

http://www.slideshare.net/jvetrau/wud2013-yvetrovmail-rumobileuikit — доклад про архитектуру проектов майлру


#### Работа с препроцессорами

https://medium.com/objects-in-space/f6f404727   
http://webuild.envato.com/blog/how-to-scale-and-maintain-legacy-css-with-sass-and-smacss/   
http://alistapart.com/article/why-sass   
http://thesassway.com/beginner/how-to-structure-a-sass-project


### Методологии

http://smacss.com/   
http://ru.bem.info/method/   
http://operatino.github.io/MCSS/


### [Гарри Робертс](https://twitter.com/csswizardry) об архитектуре

http://csswizardry.com/2013/05/hashed-classes-in-css/   
http://csswizardry.com/2012/10/a-classless-class-on-using-more-classes-in-your-html/   
http://csswizardry.com/2012/07/shoot-to-kill-css-selector-intent/   
http://csswizardry.com/2012/05/keep-your-css-selectors-short/   
http://csswizardry.com/2013/05/scope-in-css/   
http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/   
http://csswizardry.com/2013/01/you-know-your-context-on-critical-thinking-and-thinking-for-yourself/
