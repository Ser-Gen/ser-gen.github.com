## Необходимая гибкость

При всём богатстве способов стилизации элементов страницы, простота синтаксиса и ограниченность встроенных возможностей по организации таблиц стилей приводят к сложным ситуациям:

- В каждый товар в списке товаров нужно добавить список акций, но он наследует стили списка товаров. Добавим `!important`, делов-то!
- У нас десять кнопок с одинаковым внешним видом, но с классами, не соответствующими классу страницы, которую я верстаю. Сделаю одиннадцатую.
- Не знаю, делал ли кто-нибудь уже анкету на этом проекте. Сверстаю свою.
- У нас тут разметка немного поправилась. Давайте переделаем её в двенадцати шаблонах!

Какие способы вёрстки приводят к проблемам? Попробуем разобраться на простом примере.

Представим, что необходимо сверстать виджет с акциями, в котором должен быть заголовок и список акций. Можно с этой задачей справиться и так:

```html
<div id="actions">
  <h3>Header</h3>
  <ul>
    <li>item1</li>
    <li>item2</li>
    <li>item3</li>
  </ul>
</div>
```

```css
div#actions {...}
div#actions h3 {...}
div#actions ul {...}
div#actions li {...}
```

Теперь, если понадобится добавить внутрь элемента списка ещё один список, нужно писать уже более длинный и бессмысленный селектор `div#actions li li`, стилями которого придётся перебарывать стили `div#actions li`.

Проблема возникнет и в том случае, когда потребуется сверстать точно такой же виджет, только для товаров. В этой ситуации использовать такую же вёрстку не получится (нам же не нужно, чтобы виджет с товарами был с классом или идентификатором `actions`). Из-за этого приходится дублировать код или даже верстать заново, если забылось местоположение сделанного.

В конце концов, добавить что-то новое в имеющуюся вёрстку станет слишком тяжело, а переделывать участок разметки заново может быть не легче оттого, что придётся исправлять этот участок во всех шаблонах.

Чтобы получить универсальный элемент, способный использоваться снова и снова, не ломающий любые другие добавляемые в него элементы, необходимо изначально создавать его по специальным правилам.

Ко всему прочему, его элементы также должны быть переносимыми и способными использоваться отдельно от их контейнера (мало ли куда их ТЗ занесёт).

Вспомним, что требуется: виджет с заголовком и списком. Список, ко всему прочему, с акциями.

```html
<div class="Widget actions">
  <h3 class="Widget__header"></h3>
  <ul class="WidgetList">
    <li class="WidgetList__item"></li>
    <li class="WidgetList__item"></li>
    <li class="WidgetList__item"></li>
  </ul>
</div>
```

```css
.Widget {...}
.Widget.actions {...}
.WidgetList {...}
.WidgetList__item {...}
```

Поясню изменения: виджет — смысл жизни этого контейнера, поэтому и класс его семантичен — `Widget`. У виджета может быть заголовок `.Widget__header`. В виджет вставляется список `.WidgetList`, а элементы его — `.WidgetList__item`. Контейнер модифицируется при помощи класса `actions`.

Одно из важнейших качеств вёрстки — гибкость, то есть возможность использовать все элементы многократно, в разных условиях и окружениях. Гибкость обеспечивается, в первую очередь, **контекстной независимостью** элементов и их **универсальностью**.

Оценивать качество вёрстки, как и используемых в разработке приёмов, следует именно оценивая их гибкость, то есть стойкость под напором изменений.

Например, использование градиентов на ЦСС позволяет быстро изменять их цвет, не перерисовывая картинку с градиентом, а отказ от использования тегов и идентификаторов в селекторах поможет избежать большинства проблем с наследованием и со специфичностью.

Когда не ясно, _что принесёт завтрашний день_, когда вёрстка всей страницы может _полностью измениться из-за перевернувшихся концепций_ или из-за _внезапного осознания ущербности согодняшней вёрстки_, именно тогда возможность изменить поведение и отображение любого элемента на странице, не затронув все остальные, становится как никогда актуальной.

Следуйте следующим правилам:

- Специфичность элементов должна быть одинаково мала, чтобы правило было легко переопределяемым: не использовать селекторы по идентификаторам, ограничить использование каскада.
- Давать каждому элементу интерфейса уникальный класс, по которому к нему можно было бы сразу обратиться.
- Документировать, чтобы не забывать о проделанной работе.

Вёрстка содержимого должна быть максимально семантичной, чтобы все его потребители могли распознать смысл, заложенный в нём.

Вёрстка интерфейса же должна быть полной, чтобы быть легко модифицируемой, описанной во всех своих состояниях, не зависимой от окружения, не влияющей на другие элементы интерфейса.

> Как же каскад?

Он остаётся, но в обезвреженном виде. Он не должен создавать проблем, мешая добавлять элементы, но будет служить на благо разработке, применяясь внутри элементов интерфейса и их объединениях. Используя его, стоит всегда помнить, что он работает только в той структуре, которая **описана в его селекторе.**

> Нужно ли документирование?

Создавая для себя удобства в виде переиспользуемых модулей, не нужно забывать и о других разработчиках, которым они могут пригодиться. Поэтому много времени нужно уделять документированию всего, что вы делаете.

Дизайнеры же всегда должны использовать уже имеющиеся элементы интерфейса, создание нового или модификация сделанного всегда должны быть серьёзно мотивированы.

> Почему элементам нужно добавлять так много классов? Почему бы не добавить только несколько, а остальные элементы стилизовать каскадом?

Потому что каскад лишает вёрстку контекстной независимости, она становится зависима от положения элементов в документе, от их количества, от их состояния.

Мне понравилась аналогия из [этой статьи](http://csswizardry.com/2012/10/a-classless-class-on-using-more-classes-in-your-html/).

Представьте, что вы учитель и пытаетесь успокоить детей, у которых нет имён. Вы можете обратиться к ним таким образом:

- мальчик через два ряда: `el:nth-of-type() {}`
- девочка рядом с окном: `el + el {}`
- первый мальчик, сидящий на застеленной ковром зоне: `el > el:first-of-type {}`
- девочка недалеко от девочки рядом с мальчиком под лампой: `el > el + el ~ el {}`

Конечно, такая ситуация утрирована, но посыл верный — именно так верстается без должного применения классов.

Ещё одна аналогия на эту тему [в этой статье](http://engineering.appfolio.com/2012/11/16/css-architecture/): думайте о селекторе `#itemsList li div { }`, как о гранате, а о `.mainNavSub { }`, как о снайперской винтовке. Граната может отлично помочь сегодня, но никто не знает, когда невинный гражданин может попасть в зону поражения.

На первоначальное построение элементов интерфейса будет уходить больше времени, чем на «просто вёрстку». Но это время компенсируется на других этапах, когда заново перевёрстывать не будет необходимости. Чтобы не было проблем в будущем, нужно максимально качественно сделать работу **в настоящем**.

Если искать аналогии с программированием, все селекторы в стилях находятся _в глобальной области видимости_: любой селектор, состоящий из одного элемента может повлиять на любой же элемент, если у него такой же класс. Поэтому нужно, чтобы селекторы были как можно более уникальными.

Необходимо выработать способ подбора классов для элементов, чтобы их стили не пересекались друг с другом.

В программировании для решения схожей проблемы применяется **замыкание**.


## Замыкания в ЦСС

Чтобы ограничить действие цсс-правил, выбирается элемент, внутри которого будет производиться замыкание. Такие элементы называются в разных методологиях по-разному: _Блок_, _Модуль_, _Группа_. Так как слово _Фундамент_ по смыслу ближе к строительству, будет использоваться строительное понятие **Блок**.

**Блок** — законченная и независимая часть интерфейса, из **блоков** строится страница. Состоит из **элементов**. **Блок** и его **элементы** могут изменяться **модификаторами**. Да, это примерно так же, как и в [яндексовском БЭМе](http://ru.bem.info/method/definitions/).

**Блоки** могут вкладываться друг в друга, объединяться друг с другом (таким образом расширяется функциональность блока).

Класс **блока** должен начинаться с большой буквы. Если блок — кнопка, то имя его класса может быть `Btn`.

```css
.Btn {
  ...
}
```

**Элемент** — составляющая часть блока, способная использоваться отдельно от него и с разным порядком вложенности друг в друга. Представляет собой контейнеры для содержимого, изменяются модификаторами.

Класс **элемента** образуется от класса блока, в котором этот элемент находится, и слова, обозначающего предназначение элемента. Эти слова разделяются при помощи `__`.

Если **элемент** — составная часть кнопки, отвечающая за её основное действие, то его класс может быть `Btn__trigger`.

```css
.Btn__trigger {
  ...
}
```

Отображение и поведение **блоков** и **элементов** может изменяться **модификаторами**.

**Модификатор** указывается в селекторе вместе с элементом, к которому применяется.

Если **модификатор** окрашивает кнопку в цвет ошибки, его класс может быть `error`, а селектор `.Btn.error`.

```css
.Btn.error {
  ...
}
```

**Модификатор** следует добавлять тому элементу, который включает в себя все модифицируемые элементы. При этом нужно учитывать, что если таких модификаций может быть несколько, то и модифицируемые элементы могут быть разными.

Классы **блоков** и **элементов** указываются в селекторах по одному, если не изменяются **модификаторами**.


#### Важно!

Блочная структура используется для организации кода стилей, но при этом необязательно следовать ей в разметке; **Блоки** могут не содержать в себе всех **элементов**, сами **элементы** могут находиться вне **блоков**.

Таким образом, выделяя на странице такие части интерфейса, разработчик конструирует для себя набор «кирпичиков», при помощи которых строит требуемый интерфейс.


### Объединения

Плюс неиспользования тегов в селекторах — помимо прочего — в том, что блоки можно объединять друг с другом.

Например,

```html
<a href="#" class="Link">
  <span class="Icon mail"></span>
</a>
```

В этой ситуации использование двух элементов избыточно.   
Почему бы не объединить блоки в одном элементе?

```html
<a href="#" class="Link Icon mail"></a>
```


### Как назвать это?

Класс составляется из **грамотно написанных** английских слов в **единственном числе**, точно характеризующих его **смысл**. Рекомендуется некоторые слова сокращать.

Для упрощения подбора имён можно использовать следующий список обозначений:
`overlay` — элемент, покрывающий собой всё, что под ним   
`product` — товар   
`wrapper` — обёртка для какого-то элемента, блока, набора блоков   
 `active` — элемент выбран, нажат, активирован   
 `header` — заголовок   
  `first` — первый элемент в наборе   
  `intro` — сокращённое описание, предварительная информация   
   `card` — карточка (товара, акции, приза)   
   `cart` — корзина   
   `last` — последний элемент в наборе   
    `btn` — кнопка   
    `col` — колонка   
    `pop` — всплывающее окно, подсказка

```
ul.ActionGifts >
  li.ActionGift
  li.ActionGift
```


### Глобальный модификатор

Это модификатор, который можно применять к любому элементу документа.

Он может содержать как одно объявление, так и несколько, и выполняет какую-то конкретную задачу, которая обычно описывается в его селекторе.

```css
/*
<label for="input">Заголовок</label>
<input id="input" type="text" />
*/

.fieldRequired:after {
  color: red;
  content: '*';
  font-weight: bold;
  margin-left: .3em;
}
```

Применяется прежде всего для стилизации _содержимого_ документа, редактируясь вместе с ним. При помощи таких классов можно быстро добиться требуемого отображения.

Применение в вёрстке _интерфейсов_ следует ограничить, ведь используя такой «атомарный» цсс, разработчик переносит оформление в разметку, чем лишает её _гибкости_. Быстро изменить поведение всех однотипных элементов на странице не получится, если это поведение зависит от такого класса, его придётся удалять **из всех элементов во всех шаблонах**. В то же время, никто не мешает использовать примеси препроцессоров, об этом в разделе [Абстрактность](#arch-abstraktnost).


## Признаки проблем

### Модифицировать или отращивать?

Если вы заметили, что селектор превращается в башню:

```css
.Page.actions .Product__photo,
.Page.special .Product__photo,
.RelatedProducts .Product__photo
.Page.news .Product__photo {
  ...
}
```

То выделите такие стили в модификатор

```css
.Product__photo.small {
  ...
}
```

Всё оттого, что неправильно привязываться к конкретной странице в стилях, чтобы изменить отображение элемента:
  
```css
.Action__badge {
  width: 50px;
}
.Page.actionsList .Action__badge {
  width: 100px;
}
```

ведь может так получиться, что элемент должен будет одинаково изменяться не на одной странице, а на многих:

```css
.Page.actionsList .Action__badge,
.Page.actionItem .Action__badge,
.Page.cartWithActions .Action__badge,
.Page.somethingWithActionsToo .Action__badge {
  width: 100px;
}
```

В этой ситуации правильней модифицировать сам элемент:

```css
.Action__badge.full {
  width: 100px;
}
```

Кстати, если уж и пришлось давать странице класс, указывать его нужно в формате `.Page.something`.


### Универсальное правило

Если возможно, не позволяйте классу изменять слишком много свойств, ограничивайте его:

```css
.Product__code {
  color: #777;
  font-size: .75em;
  left: 100%;
  position: absolute;
  top: 10px;
}
```

Элементу `Product__code` позволено слишком много. Это ограничивает область его использования.
Некоторые свойства лучше изменять модификатором

```css
.Product__code {
  color: #777;
  font-size: .75em;
}
.Product__code.overlay {
  left: 100%;
  position: absolute;
  top: 10px;
}
```

Стили, связанные с положением и размерами элемента хорошо отделять от стилей отображения. Иногда, эти стили должны даваться разным элементам.


### Конфликтность

Бывает, нужно изменить поведение элемента несколько раз одинаково в определённых контекстах. Есть три выхода из этой ситуации.

- Использовать каскад и создавать составные селекторы. **Проблема** — составной селектор может вырасти до непотребных размеров.
- Изменять каждый элемент напрямую в его личном селекторе с требуемым каскадом. **Проблемы** — необходимость брать откуда-то пример или писать заново требуемый стиль, отсюда же проблема с повторяющимся кодом и сложностью изменения поведения в будущем. Некоторые из проблем может решить препроцессор.
- Модификация специальным классом — модификатором. **Проблемы** — именование, перенос стилизации в разметку.

Схожие проблемы и с объединением: имена модификаторов у объединяемых блоков могут совпадать.

Например, `.Btn.active.Bubble` — в этой ситуации активное состояние кнопки также является активным состоянием всплывающей индикации.

Выходов может быть несколько:

- Не объединять блоки с одинаковыми возможными модификатором, разносить их в разные сущности.
- Использовать замыкание на блок и для имён модификаторов, чтобы избежать совпадения: `.Btn.Btn--active.Bubble`

При использовании препроцессоров возможно отказаться от объединения идентичных блоков, применяя расширение их свойств. Не `.Btn.BtnGreen`, но сразу `.BtnGreen`.


## Абстрактность

Блоки отличаются их абстрактностью.
Например, можно выделить блок `.List` для сброса стилизации списков:

```css
.List {
  list-style-type: none;
  margin: 0;
  padding: 0;
}
.List__item {
  margin: 0;
}
```

Он же может применяться для расширения стилей другого блока, списка акций `.Actions__list`. При этом у этого списка могут быть свои стили, уточняющие. В этой ситуации `.List` более абстрактный, а `.Actions__list` более конкретный.
Код расширяемого блока должен находиться ниже абстрактного в таблице стилей, чтобы быть более специфичным.

Как и в ситуации с модификаторами, такое расширение возможно несколькими способами в зависимости от технических возможностей:

- указанием классов блоков вместе на одном элементе разметки — чревато переносом стилизации в разметку;
- объединением селекторов блоков вручную или при помощи препроцессора.

Первый способ проблемен тем, что переносит оформление в разметку, что затрудняет изменяемость блоков.

```html
<ul class="List Actions__list"></ul>
```

Второй в этом смысле правильней, но только при использовании препроцессоров, потому что вручную изменять селекторы придётся в разных местах и впоследствии станет сложно определить место изменения:

```css
.List,
.Actions__list {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

...

.Actions__list {
  background-color: red;
}
```

Препроцессор ([Стайлус](https://github.com/learnboost/stylus), например) имеет специальные функции для такого расширения — [примеси](https://github.com/LearnBoost/stylus/blob/master/docs/mixins.md), [расширение](https://github.com/LearnBoost/stylus/blob/master/docs/extend.md) — которые позволяют работать с расширяемым блоком напрямую:

```styl
.List {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

...

.Actions__list {

  /* в эту функцию передаётся класс,
     к которому в селектор будет добавлен класс расширяемого блока */
  @extend .List;
  background-color: red;
}
```

что компилируется в такой цсс

```css
.List,
.Actions__list {
  list-style-type: none;
  margin: 0;
  padding: 0;
}

...

.Actions__list {
  background-color: red;
}
```


## Структура итогового файла стилей

По своему предназначению и пригодности к изменениям можно выделить основные группы стилей:

1. Нормализация — стили браузеров по умолчанию приводятся к определённой кроссбраузерной основе. В селекторах используются теги, чтобы охватить все элементы.
2. Блоки — сюда входят и абстрактные, и конкретные блоки проекта.
3. Коррекция — вспомогательный слой, чтобы разрешать противоречия, с которыми сложно справляться при помощи модифицирования Блоков. Необязателен.
3. Глобальные модификаторы — классы для быстрого изменения поведения элемента. Должны делать что-то конкретное, их действие должно быть раскрыто в классе селектора.

Их можно назвать _слои_, потому что каждая последующая группа опирается на стили предыдущей. **Важно**, что такая зависимость ограничивает возможности к _изменению_ базовых слоёв, они должны быть с самого начала разработки **максимально** абстрактны и правильны, **изменения** могут привести к **проблемам!**


## Межпроектность

Если нужно разрабатывать и поддерживать сразу несколько проектов, то необходимо сделать так, чтобы блоки использовались везде одинаковые, без необходимости придумывать их всякий раз заново.

Идеально иметь межпроектную библиотеку блоков, из которой блоки копировались бы во все остальные проекты.

В первую очередь, туда добавлялись бы абстрактные блоки.

Весь код в такой библиотеке должен проверяться во всех состояниях, быть наиболее универсальным. К тому же, неуниверсальное всегда можно переопределить уже на самом проекте.

Удобнее всего работать с такой библиотекой при помощи препроцессоров или каких-либо других вспомогательных средств.

К тому же, необходимо использовать **инструмент для документации**, который бы отображал все блоки проекта. Каждый создаваемый блок должен быть максимально полно и подробно описан, чтобы не затеряться в сайте.


## В общем

- В селекторах не используются идентификаторы, ограничено применение селекторов по тегу, по типу.
- В вёрстке выделяются блоки, элементы, модификаторы.
- Стили разделяются по слоям переопределений.
- Поддержка нескольких проектов одновременно упростится с созданием общей библиотеки блоков.


## Дополнительное чтение

### Общие мысли

http://engineering.appfolio.com/2012/11/16/css-architecture/   
http://nicolasgallagher.com/about-html-semantics-front-end-architecture/   
http://philipwalton.com/articles/css-architecture/   
http://adactio.com/journal/6537/   
http://www.kapowaz.net/articles/cargo-cult-css   
http://montagejs.org/blog/2013/10/24/BEM-syntax-with-ux-in-mind/

http://www.slideshare.net/jvetrau/wud2013-yvetrovmail-rumobileuikit — доклад про архитектуру проектов майлру


#### Работа с препроцессорами

https://medium.com/objects-in-space/f6f404727   
http://webuild.envato.com/blog/how-to-scale-and-maintain-legacy-css-with-sass-and-smacss/   
http://alistapart.com/article/why-sass   
http://thesassway.com/beginner/how-to-structure-a-sass-project


### Методологии

http://smacss.com/   
http://ru.bem.info/method/   
http://operatino.github.io/MCSS/


### [Гарри Робертс](https://twitter.com/csswizardry) об архитектуре

http://csswizardry.com/2013/05/hashed-classes-in-css/   
http://csswizardry.com/2012/10/a-classless-class-on-using-more-classes-in-your-html/   
http://csswizardry.com/2012/07/shoot-to-kill-css-selector-intent/   
http://csswizardry.com/2012/05/keep-your-css-selectors-short/   
http://csswizardry.com/2013/05/scope-in-css/   
http://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/   
http://csswizardry.com/2013/01/you-know-your-context-on-critical-thinking-and-thinking-for-yourself/
