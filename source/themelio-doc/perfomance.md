## О производительности

При создании страниц с разнообразной анимацией, визуальными эффектами становится невероятно актуальной клиентская оптимизация.
Постараюсь кратко и тезисно изложить основные способы ускорения страницы.

Я не согласен с программистом из Эппла, Антти Койвисто (Antti Koivisto), работающим над Вебкитом, который [говорит](http://calendar.perfplanet.com/2011/css-selector-performance-has-changed-for-the-better/)

> «Мне кажется, что [разработчики] не должны беспокоиться об оптимизации селекторов (и, как вижу, они и так не беспокоятся), это должна быть работа движка» (“My view is that authors should not need to worry about optimizing selectors (and from what I see, they generally don’t), that should be the job of the engine.”).

Конечно, браузер всё должен делать быстро, должен быть оптимизирован. Но проблема в том, что есть много неоптимизированных браузеров, да и в оптимизированных достаточно проблем.

Разработчиков вообще может не волновать производительность, но это не означает, что так же всё равно будет пользователям.


## Загрузка страницы

От того, насколько быстро загрузится страница, зависит настроение посетителя. Ему не захочется долго наблюдать отсутствие картинок или, даже, белый экран.

Чтобы страница **быстрее отобразилась**, нужно минимизировать количество блокирующих ресурсов: файлов [стилей](www.phpied.com/css-and-the-critical-path/) (страница не начнёт отрисовываться, пока не выполнятся скрипты), скриптов (пока не загрузятся скрипты, страница не будет загружаться).

Чтобы пользователю приходилось **меньше скачивать**:
сжатие стилей, скриптов

у нас собственная версия тортойзСВН, которая при определённых операциях создаёт гзип-версию цсс и джс файлов. Таким образом, на серверах разработки мы можем работать с обычными файлами, а на рабочих серверах хранятся сжатые файлы.

[оптимизация изображений](http://tinypng.org/)

Кстати, если между вашим сервером и окружающим миром есть прокси, проверьте, не отдают ли они обычный, несжатый файл.

Они могут для общения с вашим сервером использовать протокол хттп1.0, а вам бы для передачи гзипнутых ресурсов пригодился 1.1, например.

Ещё есть [особенность заголовков](https://developers.google.com/speed/docs/best-practices/caching#LeverageProxyCaching).

Чтобы серверу приходилось **меньше отдавать**, а у пользователя всё это **отобразилось сразу**, пригодится [минимизация](http://dataurl.net/#dataurlmaker) количества изображений, к тому же, встроенные таким способом изображения отобразятся сразу при отрисовке страницы.

Чтобы страница **быстрее стала интерактивной**:

нужно продумывать работу страницы без скриптов и минимизировать скрипты;

все ресурсы страницы будут загружаться в любом случае, поэтому событие загрузки будет происходить в одно и то же время **вне зависимости от положения подключения внешних файлов**. Выход — для увеличения скорости загрузки страницы требуется **уменьшение количества подключаемых ресурсов** в момент её первоначальной загрузки. Нужно загружать только то, что **нужно** в данный момент.

Например, можно загружать только те изображения, которые могут понадобиться в самом начале использования страницы, а загрузку остальных сместить за событие `window.onload` или привязать к другому событию.

Изображения загружаются только когда укаказан его адрес в атрибуте `src`, тогда, например, верный путь к картинке можно указывать у тех изображений, которые должны загрузиться вместе со страницей, а путь остальных писать в `data-src`, заменяя им значение в `src` скриптом.

Есть плагины, реализующие такой функционал: [такой](https://github.com/fasterize/lazyload), [здесь](http://css-tricks.com/snippets/javascript/lazy-loading-images/) описывается способ, [тут](https://developers.google.com/speed/pagespeed/module/filter-lazyload-images) инструмент из пагеспида, [ещё](http://habrahabr.ru/post/87083/) по-русски.

Отслеживать процесс загрузки страницы можно при помощи инструментов. [Один из них](https://developers.google.com/speed/pagespeed/insights#url=http_3A_2F_2Fwww.officemag.ru_2F&mobile=false&rule=____critical__path) может показать ресурсы, из-за которых загрузка страницы может задерживаться. [Так](http://www.youtube.com/watch?v=NTAi3ILOa1c) ею можно пользоваться. [Там же](https://developers.google.com/speed/pagespeed/insights) есть возможность проверить сайт на наличие проблем. [Здесь](http://www.webpagetest.org/) можно увидеть, к чему стремиться.

Ещё производительность можно оценить [здесь](http://httparchive.org/viewsite.php?pageid=7994602).


## Работа страницы

Иногда может возникнуть ситуация, когда страница начинает долго и мучительно прокручиваться, анимации отрисовываются недостаточно плавно и без достаточного количества кадросекунд.

Всякий раз, когда браузеру нужно перерисовать элемент, он вычисляет его стили (?), обращаясь к нему по селектору.

Искать элемент браузер может долго.

Вычислять стили может быть сложно.

Чем сложней сопоставить элементы с их селекторами, чем тяжелей вычисления, тем дольше будет происходить перерисовка страницы или её части.

Оптимизируя страницы, важно понять, что каждый кадр браузер должен отрисовать **за минимальное время**. Представим, сколько нужно потратить времени браузеру, чтобы отрисовать видимую часть страницы для получения определённого количества кадров в секунду:

	60мс ~ 16,67 кадр/с
	30мс ~ 33,3[3] кадр/с
	20мс ~ 50 кадр/с
	16,67мс ~ 60 кадр/с

Цель — сделать, чтобы задержка при отрисовке была **16,67мс и ниже** (следовательно, количество кадросекунд было **60 и выше**).

[Как браузер отрисовывает страницы](http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/).


### ЦСС

На отрисовку и перерисовку страницы благотворно влияют:

- отсутствие **ресурсоёмких свойств** (тени, скругления углов, [их сочетание](http://www.html5rocks.com/en/tutorials/speed/css-paint-times/)) и **значений** (градиенты, растяжение фоновых изображений, трансформации, крупные тени), вместо них **изображения**;
- **уникальные классы** для всех элементов, [замыкание классов](http://csswizardry.com/2013/05/scope-in-css/), производительные селекторы (из одного класса, с возможностью указания контекста также классом; не по тегу, не по атрибуту, не по псевдоселектору, не универсальный).

Максимально сокращайте глубину вложенности элементов, входящих в каскад селектора.   
[Вот ещё про производительность](http://events.yandex.ru/events/yasubbotnik/kiev-may-2011/talks/232/)   
[Про профилирование](http://www.slideshare.net/yandex/profiler-15438825)


#### Профилирование

следить **за временем сопоставления селекторов**:

профилирование селекторов цсс поможет обнаружить селекторы, на которые браузер тратит слишком много времени.

Селекторы по одному идентификатору или одному классу — максимально производительны, так как браузеру приходится искать только один элемент.

Селекторы разбираются [справа налево](http://www.youtube.com/watch?v=a2_6bGNZ7bA#t=904s), поэтому не нужно использовать наиболее встречающийся на странице элемент в самой правой части. Такой элемент может быть тегом, например.

Селектор по потомку, самый правый из которых — тег, [недостаточно производителен](https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Writing_efficient_CSS#Avoid_the_descendant_selector.21)

Селекторы по атрибутам, псевдоселекторы тоже недостаточно производительны, так как браузеру, помимо нахождения обычных элементов нужно также разбирать их атрибуты или местонахождение в дереве.

Про то, как браузер работает с селекторами, также написано [здесь](http://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/).

области отрисовки **не должны быть слишком большими**:

самая плохая ситуация — когда перерисовывается вся видимая часть страницы; это может быть вызвано, например, фоновым изображением с фиксированным положением, фоновым изображением с изменяемыми размерами в зависимости от размеров документа;

если обнаружены **большие области перерисовки**:

попробовать переверстать элементы в этих областях, если переверстать нельзя — сделать перерисовку как можно менее дорогой, не использовать тяжёлые для отрисовки свойства цсс или значения свойств (например, сочетание тени блока и скругления его углов замедляет отрисовку страницы [намного сильней](http://frontender.info/css-paint-times/), чем каждое из этих свойств в отдельности)

скорость отрисовки страницы (например, в Continuous Painting Mode Хрома) не должна быть большой, также не стоит забывать, что помимо отрисовки есть ещё и перекомпоновка, на которую тоже приходится тратить время

[хорошая статья](http://updates.html5rocks.com/2013/02/Profiling-Long-Paint-Times-with-DevTools-Continuous-Painting-Mode) про возможности Хрома для профилирования. Уже не очень, так как эту возможность из Хрома убрали. Но её ещё можно найти в [версии 29, портативной](http://stadt-bremerhaven.de/portable-google-chrome-29/), например.

Вот ещё про профилирование селекторов:   
http://andy.edinborough.org/CSS-Stress-Testing-and-Performance-Profiling   
http://noteskeeper.ru/638/   
http://perfectionkills.com/profiling-css-for-fun-and-profit-optimization-notes/   

Ускорение анимации на цсс `transform: translateZ(0)` для современных браузеров уже не так актуально, в хроме [включается автоматически в различных ситуациях](http://www.html5rocks.com/en/tutorials/speed/layers/, возможны проблемы, описанные [здесь](http://blog.alexmaccaw.com/css-transitions), следует учитывать [особенности](http://www.aerotwist.com/blog/on-translate3d-and-layer-creation-hacks/), проверять поддержку можно [так](http://stackoverflow.com/questions/5661671/detecting-transform-translate3d-support) и [так](http://stackoverflow.com/questions/11628390/how-to-detect-css-translate3d-without-the-webkit-context).

Ускорить отрисовку анимации на цсс можно при помощи этого класса

	.hwAccelerate {
		-webkit-transform: translate3d(0,0,0);
	     -moz-transform: translate3d(0,0,0);
	       -o-transform: translate3d(0,0,0);
		        transform: translate3d(0,0,0);
	}


Всё-таки на универсальный селектор тратится слишком много времени.

	*,
	*:before,
	*:after {
	    -webkit-box-sizing: border-box;
	       -moz-box-sizing: border-box;
	            box-sizing: border-box;
	}

Лучше свойство `box-sizing` лучше менять у элемента отдельно.

Анимация быстрее на цсс, чем на джс
	http://ejohn.org/blog/css-animations-and-javascript/
	http://css3.bradshawenterprises.com/blog/jquery-vs-css3-transitions/
	http://dev.opera.com/articles/view/css3-vs-jquery-animations/
	http://stackoverflow.com/questions/10984771/whats-faster-css3-transitions-or-jquery-animations
	http://stackoverflow.com/questions/2999749/performance-of-css-transitions-vs-js-animation-packages
	[Про параметр для анимации спрайтовых изображений](http://lea.verou.me/2011/09/pure-css3-typing-animation-with-steps/)
	[В документации](https://developer.mozilla.org/en-US/docs/Web/CSS/timing-function#The_steps%28%29_class_of_timing-functions)
	[Пример](http://jsfiddle.net/simurai/CGmCe/)


### ДЖС

кеширование,
как можно реже перемещаться по дереву (кешировать узлы), ещё реже его изменять (кешировать изменения пачкой их применять)
отсутствие множества таймеров и изменения стилей элементов,
работа с джс элементами, а не джкуери



## Про кеширование

Если изменяется контент, ФФ загружает его, но не отрисовывает; отрисовка только после перезагрузки страницы.
Хром не отрисовывает и не загружает.

За кешированием цсс и джс следить не приходится, они скачиваются тогда, когда это действительно нужно.
Проблема связана с изображениями, в путь к ним необходимо писать гетзапрос, который заставит браузер обновить изображение. Но если разработчик забудет это сделать, у пользователя будет устаревшая, неправильная картинка. В некоторых ситуациях может помочь датаури. Вместе с цсс будут обновляться и зашифрованные картинки.

Все браузеры, кроме ИЕ, загружают и отображают изменившиеся картинки.
ФФ загружает, но не отображает. Он может отобразить только предыдущее закешированное изображение.

Чтобы закешированное не трогалось как можно дольше, экспарес у таких ресурсов делается как можно большим.
Если нужно обновить у пользователей определённый файл, ему нужно добавить после ссылки на него текст со знаком вопроса, например ?some_text_here. Браузер по такой новой ссылке будет скачивать файл заново.




## Дополнительное чтение

[Общие моменты в оптимизации](http://csswizardry.com/2013/01/front-end-performance-for-web-designers-and-front-end-developers/)
[Ещё один вариант, по-русски](http://habrahabr.ru/post/178561/)
[Оптимизация джс](http://habrahabr.ru/post/137318/)

[Как работают браузеры](http://www.html5rocks.com/ru/tutorials/internals/howbrowserswork/)

[Производительность шрифтов](http://habrahabr.ru/post/159907/)
[Способ оптимизации шрифтов](http://cssing.org.ua/2009/10/24/font-face/)
[Конвертор шрифтов](http://www.font2web.com/)

[Михаил Корепанов — профилирование](http://www.slideshare.net/yandex/profiler-15438825)

[Про отрисовку и её ускорение](http://www.phpied.com/rendering-repaint-reflowrelayout-restyle/)

[Как измеряется скорость](https://sites.google.com/a/webpagetest.org/docs/using-webpagetest/metrics/speed-index)

[Статьи про оптимизацию](http://habrahabr.ru/hub/client_side_optimization/)

[Оптимизация главной МейлРу](http://habrahabr.ru/company/mailru/blog/142193/)

[Инструмент для изучения](http://modpagespeed.com/)
[Его анонс](https://developers.google.com/speed/pagespeed/mod)
[Видео о нём](http://www.youtube.com/watch?v=6uCAdQSHhmA)