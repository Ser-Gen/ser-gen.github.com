# Идеология

## Путь верстальщика

Наиболее благоприятная ситуация в начале пути — когда готовы все макеты. В любом случае, необходимо постараться выделить как можно больше стандартных, не зависящих от окружения элементов.
Конечно, *многое зависит от дизайнеров*, которые должны максимально широко использовать существующие элементы, не наращивая количество похожих по смыслу, но разных по отображению элементов.



### Классификация элементов

Нужно понимать, что классы, состоящие из одного простого, часто встречающегося слова легко могут быть повторены при вёрстке других, совершенно не связанных с первоначальными блоками. Потому такие простые классы следует использовать в более сложных селекторах, привязываясь к более уникальным, неповторимым и не таким абстрактным классам.
Большие блоки следует именовать согласно их предназначению, находящиеся в них — *имяблокаЗначение* и так до глубины, когда можно использовать классы из одного слова (не забывайте, у нас применяется *стильВерблюда*).

Таким образом, для структуры

	.feedbackForm
		.feedbackFormHeader.big
			.arrow
			.text
		.feedbackFormContent
			.form
			.info

соответствующий ЦСС может быть таким

	.feedbackForm {}

	.feedbackFormHeader {}
	.feedbackFormHeader.big {}
	.feedbackFormHeader .arrow {}
	.feedbackFormHeader .text {}

	.feedbackFormContent {}
	.feedbackFormContent .form {}
	.feedbackFormContent .info {}

В то же время, подобную структуру следует строить в условиях, когда необходимо создать независимый блок, не похожий ни на что уже имеющееся. В первую очередь следует стараться создавать и после использовать именно независимые от содержимого блоки:

	.mainContainer

	.mainContainerHeader.big
		...

	.mainContainerContent
		...

Затем можно расширить стили этих классов, добавив специфичные и используемые только в нужном контексте:

	.mainContainer.feedbackForm

	.mainContainerHeader.big
		...

	.mainContainerContent.feedbackFormContent
		...

Мы не повторяем уже имеющиеся стили для `.mainContainer`, но расширяем их для конкретной ситуации.



#### Модификаторы

+ универсальные модификаторы
+ модификаторы элементов
+ контекстные модификаторы

*Универсальные модификаторы* могут применяться к многим, иногда совсем разнородным элементам. Они могут пригодиться, когда нужно изменить цвет текста, отступ по образу соседних блоков. Класс такого модификатора должен быть максимально неповторим, чтобы не совпасть с классом какого-нибудь нового блока. Такие классы также называют *хелперами* (помощниками).

[Запрещение выделения текста](http://stackoverflow.com/questions/826782/css-rule-to-disable-text-selection-highlighting)

	.noUserSelect {
		cursor: default;
		-webkit-touch-callout: none;
	  -webkit-user-select: none;
	     -moz-user-select: none;
	      -ms-user-select: none;
	          user-select: none;
	}

*Модификаторы элементов* могут применяться только к определённым элементам, изменяя их поведение. Их класс может быть коротким при условии, что и в селекторе CSS они будут указываться вместе с классом изменяемого элемента.

	.btn.big {
		font-size: 2em;
	}

*Контекстные модификаторы* применяются для того, чтобы изменить поведение элемента при наступлении определённой ситуации. Можно использовать их, например, если у пользователя отключён джаваскрипт и в *таком контексте* ни к чему выводить элементы от него зависящие.

	.noJS .sliderSwitch {
		display: none;
	}

Если какие-то свойства будут меняться модификаторами, лучше *вынести их в модификаторы* насовсем. Иначе придётся переопределять эти основные стили, иногда неоднократно.

Старайтесь указывать модификаторы *после самих модифицируемых элементов*, отделяя их от других блоков переводами строк.

Классы для элемента следует указывать в порядке их глобальности

	<div class="contentWrapper stowageControl top"></div>

Конечная цель выделения независимых элементов, универсальных модификаторов — *создание базы кода*, который может использоваться везде, во всех новых проектах, дорабатываясь и дополняясь.
Добавляя такой элемент в таблицу стилей, разработчик *обязан упомянуть* его в документации.



### Специфичность

Не нужно использовать `!important`, он делает значение свойства суперспецифичным, а, значит, с большим трудом переопределяемым, потому и использовать его следует с большой осторожностью, только там, где есть полнейшая уверенность в будущем *этого конкретного правила*.
Например

	.hide {
		display: none !important;
	}

Похожая ситуация с использованием идентификаторов (`#id`) в селекторах. Идентификатор сам по себе очень специфичен, он [*в 255 раз*](http://codepen.io/chriscoyier/pen/lzjqh) специфичнее селектора с классом (если не использовать мощнейший `!important`) [и вот почему](http://stackoverflow.com/a/12003060). Стилизовать элемент, привязываясь к идентификатору его контейрнера, означает ограничивать себя в его гибкости (что если этот элемент придётся перенести в другой контейнер?).

Если элементы, с которыми нужно взаимодействовать при помощи скрипта, неоднократно встречаются в документе или однотипны, то следует использовать класс со специальным префиксом `js-`. Такой класс *нельзя* использовать для стилизации.

Присваивать идентификаторы и скриптовые классы элементам *должны программисты* клиентских скриптов.



### Производительность CSS

Чтобы страница отрисовывавалась и перерисовывалась быстрее, стоит обратить внимание на производительность CSS.
На неё влияют:

- Селекторы
- Переопределения
- Ресурсоёмкость свойств

*Селекторы* разбираются браузерами [справа налево](https://developer.mozilla.org/en-US/docs/CSS/Writing_Efficient_CSS?redirectlocale=en-US&redirectslug=Writing_Efficient_CSS#How_the_Style_System_Matches_Rules), поэтому нет смысла использовать такой селектор

	html body .listItemHeaderIcon

так как даже если у вас на странице только один `.listItemHeaderIcon`, браузеру придётся удостовериться, что он находится в `body`, а он, в свою очередь, в `html`. Таким образом, стоит обращать внимание и *на глубину вложенности элементов*, перечисленных в селекторах.
Если в документе есть несколько элементов, которые совпадают с указанием в самой правой части селектора, то браузер всё равно постарается сопоставить его с этими элементами, даже если все остальные указания к этим элементам отношения не имеют.
Например

	.listItems a {}

	.mainMenu a {}

Браузер будет сопоставлять эти селекторы со всеми ссылками на странице, хоть если к блокам `listItems` и `mainMenu` они и не будут иметь никакого отношения.
[На тему сопоставления селекторов](http://www.youtube.com/watch?v=a2_6bGNZ7bA#t=904s)
Не указывайте в селекторе класс вместе с тегом, которому он принадлежит, если только разные элементы с таким классом не должны вести себя по-разному.
Идеальной может считаться ситуация, при которой *каскад совсем не используется*, тогда браузер сразу будет находить нужный элемент и стилизовать его, не тратя время на обход дерева элементов.

Даже селекторы с каскадом, для которых не находятся подходящие элементы, недостаточно производительны. [Доказано](http://noteskeeper.ru/638/)
Идеально было бы *формировать и кешировать для каждой страницы* свою таблицу стилей.

Нерационально *переопределяя* ранее установленные свойства, вы заставляете браузер тратить время на постоянное преображение элемента.
Идеально было бы *совсем не переопределять*, а сразу *устанавливать нужное*.

Некоторые из модных сейчас свойств CSS3 *ресурсоёмки* и могут приводить к тому, что на слабых машинах страница будет прокручиваться с низким числом кадросекунд.
Например, `box-shadow` часто негативно влияет на скорость отрисовки страницы, особенно при большом значении размытия. Предпочтительней в этой ситуации использовать — если ситуация позволяет — `background-image: linear-gradient` или картинки.
Идеально было бы *совсем не использовать* эти свойства.

Но идеал, иногда, не достижим.
Вёрстка — это постоянный поиск компромиссов. Не нужно этого стесняться, именно в таком поиске могут появиться на самом деле гениальные приёмы и способы работы, а к идеалу нужно стремиться всегда!

Почитать ещё о производительности можно [здесь](https://developer.mozilla.org/en-US/docs/CSS/Writing_Efficient_CSS?redirectslug=Writing_Efficient_CSS) и [тут](https://developers.google.com/speed/docs/best-practices/rendering) и производительности селекторов, в частности, [там](http://www.stevesouders.com/blog/2009/06/18/simplifying-css-selectors/)



### Немного о производительности JS

Идентификатор следует использовать в селекторах скриптов, так как поиск элемента по идентификатору скриптом выполняется [*в несколько раз быстрее*](http://jsperf.com/id-vs-class-vs-tag-selectors/2), чем по классу. Для повторяющихся элементов нужно применять класс с префиксом `js-`.

[Лучше добавлять класс, а не менять инлайновый стиль](http://jsperf.com/addclass-versus-style-attribute).

Вообще, на [этом сайте](http://jsperf.com) множество тестов производительности.